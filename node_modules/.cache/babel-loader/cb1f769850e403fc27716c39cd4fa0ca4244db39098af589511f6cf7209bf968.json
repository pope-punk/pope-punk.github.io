{"ast":null,"code":"// Matrix utility functions for hexagonal church pew arrangements\n\n// Define canonical reset state - all pews on outer ring\nexport const CANONICAL_STATE = [[0, 0, 0],\n// innermost ring\n[0, 0, 0],\n// middle ring\n[2, 2, 2] // outermost ring\n];\n\n// Validate a matrix configuration\nexport const isValidMatrix = matrix => {\n  if (!matrix || !Array.isArray(matrix) || matrix.length !== 3) return false;\n\n  // Check each row is valid\n  for (let r = 0; r < 3; r++) {\n    if (!Array.isArray(matrix[r]) || matrix[r].length !== 3) return false;\n    for (let d = 0; d < 3; d++) {\n      if (matrix[r][d] !== 0 && matrix[r][d] !== 2) return false;\n    }\n  }\n\n  // Count total pews\n  const totalPews = matrix.flat().reduce((sum, val) => sum + val, 0);\n  if (totalPews !== 6) return false;\n\n  // Check innermost ring constraint (at most one pair)\n  const innerRingTotal = matrix[0].reduce((sum, val) => sum + val, 0);\n  if (innerRingTotal > 2) return false;\n  return true;\n};\n\n// Calculate transition steps between two matrices\nexport const calculateTransition = (startMatrix, endMatrix) => {\n  if (!isValidMatrix(startMatrix) || !isValidMatrix(endMatrix)) {\n    return [];\n  }\n  const steps = [];\n\n  // Step 1: Save the initial state\n  steps.push({\n    matrix: JSON.parse(JSON.stringify(startMatrix)),\n    description: \"Initial arrangement\"\n  });\n\n  // Step 2: Transition to canonical state (all pews on outer ring)\n  const toCanonicalSteps = transitionToCanonical(startMatrix);\n  steps.push(...toCanonicalSteps);\n\n  // Step 3: Transition from canonical to target state\n  const fromCanonicalSteps = transitionFromCanonical(CANONICAL_STATE, endMatrix);\n  steps.push(...fromCanonicalSteps);\n  return steps;\n};\n\n// Helper to move pews to canonical state (all on outer ring)\nconst transitionToCanonical = matrix => {\n  const steps = [];\n  const currentMatrix = JSON.parse(JSON.stringify(matrix));\n\n  // Move pews from inner ring to middle ring\n  for (let d = 0; d < 3; d++) {\n    if (currentMatrix[0][d] === 2) {\n      currentMatrix[0][d] = 0;\n      currentMatrix[1][d] = 2;\n      steps.push({\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\n        description: `Move pew from inner ring to middle ring at diagonal ${d}`\n      });\n    }\n  }\n\n  // Move pews from middle ring to outer ring\n  for (let d = 0; d < 3; d++) {\n    if (currentMatrix[1][d] === 2) {\n      currentMatrix[1][d] = 0;\n      currentMatrix[2][d] = 2;\n      steps.push({\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\n        description: `Move pew from middle ring to outer ring at diagonal ${d}`\n      });\n    }\n  }\n\n  // Make sure outer ring has all 3 pairs\n  let missingDiagonals = [];\n  for (let d = 0; d < 3; d++) {\n    if (currentMatrix[2][d] !== 2) {\n      missingDiagonals.push(d);\n    }\n  }\n\n  // Redistribute outer ring pews if needed\n  if (missingDiagonals.length > 0) {\n    let extraDiagonals = [];\n    for (let d = 0; d < 3; d++) {\n      if (currentMatrix[2][d] > 2) {\n        extraDiagonals.push(d);\n      }\n    }\n    for (let i = 0; i < Math.min(missingDiagonals.length, extraDiagonals.length); i++) {\n      currentMatrix[2][extraDiagonals[i]] -= 2;\n      currentMatrix[2][missingDiagonals[i]] = 2;\n      steps.push({\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\n        description: `Rotate pew on outer ring from diagonal ${extraDiagonals[i]} to diagonal ${missingDiagonals[i]}`\n      });\n    }\n  }\n\n  // If we reached canonical state, add a step\n  if (JSON.stringify(currentMatrix) === JSON.stringify(CANONICAL_STATE)) {\n    steps.push({\n      matrix: JSON.parse(JSON.stringify(CANONICAL_STATE)),\n      description: \"Reached canonical arrangement (all pews on outer ring)\"\n    });\n  }\n  return steps;\n};\n\n// Helper to move from canonical state to target state\nconst transitionFromCanonical = (canonicalMatrix, targetMatrix) => {\n  const steps = [];\n  const currentMatrix = JSON.parse(JSON.stringify(canonicalMatrix));\n\n  // Move pews from outer ring to middle ring\n  for (let d = 0; d < 3; d++) {\n    if (targetMatrix[1][d] === 2 && currentMatrix[1][d] !== 2) {\n      currentMatrix[2][d] = 0;\n      currentMatrix[1][d] = 2;\n      steps.push({\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\n        description: `Move pew from outer ring to middle ring at diagonal ${d}`\n      });\n    }\n  }\n\n  // Move pews from middle ring to inner ring\n  for (let d = 0; d < 3; d++) {\n    if (targetMatrix[0][d] === 2 && currentMatrix[0][d] !== 2) {\n      currentMatrix[1][d] = 0;\n      currentMatrix[0][d] = 2;\n      steps.push({\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\n        description: `Move pew from middle ring to inner ring at diagonal ${d}`\n      });\n    }\n  }\n\n  // Add a final step showing the target arrangement\n  if (JSON.stringify(currentMatrix) !== JSON.stringify(targetMatrix)) {\n    steps.push({\n      matrix: JSON.parse(JSON.stringify(targetMatrix)),\n      description: \"Final arrangement reached\"\n    });\n  }\n  return steps;\n};\n\n// Get a descriptive name for each position in the matrix\nexport const getPositionName = (ring, diagonal) => {\n  const ringNames = [\"Inner\", \"Middle\", \"Outer\"];\n  const diagonalNames = [\"Horizontal\", \"Top-Right to Bottom-Left\", \"Top-Left to Bottom-Right\"];\n  return `${ringNames[ring]} Ring, ${diagonalNames[diagonal]} Diagonal`;\n};\n\n// Generate a default matrix with positions\nexport const generateDefaultMatrix = () => {\n  return JSON.parse(JSON.stringify(CANONICAL_STATE));\n};","map":{"version":3,"names":["CANONICAL_STATE","isValidMatrix","matrix","Array","isArray","length","r","d","totalPews","flat","reduce","sum","val","innerRingTotal","calculateTransition","startMatrix","endMatrix","steps","push","JSON","parse","stringify","description","toCanonicalSteps","transitionToCanonical","fromCanonicalSteps","transitionFromCanonical","currentMatrix","missingDiagonals","extraDiagonals","i","Math","min","canonicalMatrix","targetMatrix","getPositionName","ring","diagonal","ringNames","diagonalNames","generateDefaultMatrix"],"sources":["C:/ApplicationDev/pope-punk.github.io/src/utils/matrixUtils.js"],"sourcesContent":["// Matrix utility functions for hexagonal church pew arrangements\r\n\r\n// Define canonical reset state - all pews on outer ring\r\nexport const CANONICAL_STATE = [\r\n  [0, 0, 0], // innermost ring\r\n  [0, 0, 0], // middle ring\r\n  [2, 2, 2]  // outermost ring\r\n];\r\n\r\n// Validate a matrix configuration\r\nexport const isValidMatrix = (matrix) => {\r\n  if (!matrix || !Array.isArray(matrix) || matrix.length !== 3) return false;\r\n  \r\n  // Check each row is valid\r\n  for (let r = 0; r < 3; r++) {\r\n    if (!Array.isArray(matrix[r]) || matrix[r].length !== 3) return false;\r\n    for (let d = 0; d < 3; d++) {\r\n      if (matrix[r][d] !== 0 && matrix[r][d] !== 2) return false;\r\n    }\r\n  }\r\n  \r\n  // Count total pews\r\n  const totalPews = matrix.flat().reduce((sum, val) => sum + val, 0);\r\n  if (totalPews !== 6) return false;\r\n  \r\n  // Check innermost ring constraint (at most one pair)\r\n  const innerRingTotal = matrix[0].reduce((sum, val) => sum + val, 0);\r\n  if (innerRingTotal > 2) return false;\r\n  \r\n  return true;\r\n};\r\n\r\n// Calculate transition steps between two matrices\r\nexport const calculateTransition = (startMatrix, endMatrix) => {\r\n  if (!isValidMatrix(startMatrix) || !isValidMatrix(endMatrix)) {\r\n    return [];\r\n  }\r\n  \r\n  const steps = [];\r\n  \r\n  // Step 1: Save the initial state\r\n  steps.push({\r\n    matrix: JSON.parse(JSON.stringify(startMatrix)),\r\n    description: \"Initial arrangement\"\r\n  });\r\n  \r\n  // Step 2: Transition to canonical state (all pews on outer ring)\r\n  const toCanonicalSteps = transitionToCanonical(startMatrix);\r\n  steps.push(...toCanonicalSteps);\r\n  \r\n  // Step 3: Transition from canonical to target state\r\n  const fromCanonicalSteps = transitionFromCanonical(CANONICAL_STATE, endMatrix);\r\n  steps.push(...fromCanonicalSteps);\r\n  \r\n  return steps;\r\n};\r\n\r\n// Helper to move pews to canonical state (all on outer ring)\r\nconst transitionToCanonical = (matrix) => {\r\n  const steps = [];\r\n  const currentMatrix = JSON.parse(JSON.stringify(matrix));\r\n  \r\n  // Move pews from inner ring to middle ring\r\n  for (let d = 0; d < 3; d++) {\r\n    if (currentMatrix[0][d] === 2) {\r\n      currentMatrix[0][d] = 0;\r\n      currentMatrix[1][d] = 2;\r\n      steps.push({\r\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\r\n        description: `Move pew from inner ring to middle ring at diagonal ${d}`\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Move pews from middle ring to outer ring\r\n  for (let d = 0; d < 3; d++) {\r\n    if (currentMatrix[1][d] === 2) {\r\n      currentMatrix[1][d] = 0;\r\n      currentMatrix[2][d] = 2;\r\n      steps.push({\r\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\r\n        description: `Move pew from middle ring to outer ring at diagonal ${d}`\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Make sure outer ring has all 3 pairs\r\n  let missingDiagonals = [];\r\n  for (let d = 0; d < 3; d++) {\r\n    if (currentMatrix[2][d] !== 2) {\r\n      missingDiagonals.push(d);\r\n    }\r\n  }\r\n  \r\n  // Redistribute outer ring pews if needed\r\n  if (missingDiagonals.length > 0) {\r\n    let extraDiagonals = [];\r\n    for (let d = 0; d < 3; d++) {\r\n      if (currentMatrix[2][d] > 2) {\r\n        extraDiagonals.push(d);\r\n      }\r\n    }\r\n    \r\n    for (let i = 0; i < Math.min(missingDiagonals.length, extraDiagonals.length); i++) {\r\n      currentMatrix[2][extraDiagonals[i]] -= 2;\r\n      currentMatrix[2][missingDiagonals[i]] = 2;\r\n      steps.push({\r\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\r\n        description: `Rotate pew on outer ring from diagonal ${extraDiagonals[i]} to diagonal ${missingDiagonals[i]}`\r\n      });\r\n    }\r\n  }\r\n  \r\n  // If we reached canonical state, add a step\r\n  if (JSON.stringify(currentMatrix) === JSON.stringify(CANONICAL_STATE)) {\r\n    steps.push({\r\n      matrix: JSON.parse(JSON.stringify(CANONICAL_STATE)),\r\n      description: \"Reached canonical arrangement (all pews on outer ring)\"\r\n    });\r\n  }\r\n  \r\n  return steps;\r\n};\r\n\r\n// Helper to move from canonical state to target state\r\nconst transitionFromCanonical = (canonicalMatrix, targetMatrix) => {\r\n  const steps = [];\r\n  const currentMatrix = JSON.parse(JSON.stringify(canonicalMatrix));\r\n  \r\n  // Move pews from outer ring to middle ring\r\n  for (let d = 0; d < 3; d++) {\r\n    if (targetMatrix[1][d] === 2 && currentMatrix[1][d] !== 2) {\r\n      currentMatrix[2][d] = 0;\r\n      currentMatrix[1][d] = 2;\r\n      steps.push({\r\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\r\n        description: `Move pew from outer ring to middle ring at diagonal ${d}`\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Move pews from middle ring to inner ring\r\n  for (let d = 0; d < 3; d++) {\r\n    if (targetMatrix[0][d] === 2 && currentMatrix[0][d] !== 2) {\r\n      currentMatrix[1][d] = 0;\r\n      currentMatrix[0][d] = 2;\r\n      steps.push({\r\n        matrix: JSON.parse(JSON.stringify(currentMatrix)),\r\n        description: `Move pew from middle ring to inner ring at diagonal ${d}`\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Add a final step showing the target arrangement\r\n  if (JSON.stringify(currentMatrix) !== JSON.stringify(targetMatrix)) {\r\n    steps.push({\r\n      matrix: JSON.parse(JSON.stringify(targetMatrix)),\r\n      description: \"Final arrangement reached\"\r\n    });\r\n  }\r\n  \r\n  return steps;\r\n};\r\n\r\n// Get a descriptive name for each position in the matrix\r\nexport const getPositionName = (ring, diagonal) => {\r\n  const ringNames = [\"Inner\", \"Middle\", \"Outer\"];\r\n  const diagonalNames = [\"Horizontal\", \"Top-Right to Bottom-Left\", \"Top-Left to Bottom-Right\"];\r\n  \r\n  return `${ringNames[ring]} Ring, ${diagonalNames[diagonal]} Diagonal`;\r\n};\r\n\r\n// Generate a default matrix with positions\r\nexport const generateDefaultMatrix = () => {\r\n  return JSON.parse(JSON.stringify(CANONICAL_STATE));\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}